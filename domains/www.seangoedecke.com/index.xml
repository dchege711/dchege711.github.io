<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>www.seangoedecke.com on Chege's Blog</title><link>https://www.curiosities.dev/domains/www.seangoedecke.com/</link><description>Recent content in www.seangoedecke.com on Chege's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 16 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.curiosities.dev/domains/www.seangoedecke.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Leading Big Projects</title><link>https://www.curiosities.dev/computer-science/swe-in-practice/leading-big-projects/</link><pubDate>Sat, 16 Nov 2024 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/swe-in-practice/leading-big-projects/</guid><description>Create clarity for everyone such that they know what they need to do and how it fits into the bigger picture. Communicate openly. Give team members a stage to be publicly competent. Pick up the grunt work that others might not find enjoyable. Allocate time for support work, e.g., reviewing user feedback and error reports. Usually, the reason a project is difficult isn&amp;rsquo;t that you&amp;rsquo;re pushing the boundaries of technology, it&amp;rsquo;s that you&amp;rsquo;re dealing with ambiguity: unclear direction; messy, complicated humans; or legacy systems with behavior you can&amp;rsquo;t predict.</description></item><item><title>Perspectives on Software Engineering</title><link>https://www.curiosities.dev/computer-science/swe-in-practice/2022-06-06-perspectives-on-swe/</link><pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/swe-in-practice/2022-06-06-perspectives-on-swe/</guid><description>On the Clean Code Movement Good enough is good enough. The architectural choices and bugs in the implementation tend to be more impactful, so focus more on those.
Be conservative in what you consider technical debt. It should be something that slows down current/future changes, and not code that doesn&amp;rsquo;t &amp;ldquo;feel nice&amp;rdquo;. A code base that is free if technical debt is likely over-emphasizing polish over delivery.
Abstractions and indirections in the name of future-proofing tend to be wrong especially when treading new paths, where you can&amp;rsquo;t reliably predict the future.</description></item></channel></rss>