<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>git-scm.com on Chege's Blog</title><link>https://www.curiosities.dev/domains/git-scm.com/</link><description>Recent content in git-scm.com on Chege's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 22 Jun 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.curiosities.dev/domains/git-scm.com/index.xml" rel="self" type="application/rss+xml"/><item><title>06. Version Control (Git)</title><link>https://www.curiosities.dev/computer-science/the-missing-cs-semester/06-version-control-git/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/the-missing-cs-semester/06-version-control-git/</guid><description>Version Control Systems track changes to a folder and its contents in a series of snapshots. Each snapshot encapsulates the entire state of files/folders within a top-level directory.
Git&amp;rsquo;s interface is a leaky abstraction. While the interface is at times ugly, its underlying design and ideas are beautiful. A bottom-up explanation of Git therefore makes more sense.
The abstraction is leaky in the sense that to wield it effectively, the user must understand the underlying data model, e.</description></item><item><title>Testing in a Monorepo</title><link>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/testing/</link><pubDate>Sat, 22 Jun 2024 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/testing/</guid><description>Testing Web Components While any test framework can work, it&amp;rsquo;s better to test web components in a browser environment because that&amp;rsquo;s where they&amp;rsquo;ll be used. Node-based frameworks would require too much shimming of DOM calls that&amp;rsquo;d make the tests unrepresentative. and are good options for browser-based testing.
is powered by ES-build, and so is the client-side of the app; let&amp;rsquo;s go down this path and see where it leads.</description></item><item><title>Software Engineering Journal Reviews</title><link>https://www.curiosities.dev/computer-science/2022-01-16-swe-journal-reviews/</link><pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/2022-01-16-swe-journal-reviews/</guid><description>Formal Software Design Alloy is an open-source language and analyzer for software modeling. An Alloy model is a collection of constraints that describe a set of structures, e.g. all possible security configurations of a web application. Alloy&amp;rsquo;s tool, the Alloy Analyzer is a solver that takes the constraints of a model and finds structures that satisfy them.
ðŸ“‘ The Alloy Analyzer leverages a SAT solver, and this precludes Alloy from analyzing optimization problems.</description></item><item><title>[ToDo] Site Health</title><link>https://www.curiosities.dev/todo/site-health/</link><pubDate>Sat, 14 Aug 2021 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/todo/site-health/</guid><description>Things that make the personal website better, but are orthogonal to adding new content.
ðŸŸ¡ Achieve parity between .md and .html content files. Right now, the scripts treat .md as the identifier for site content, which means .html files lack full YAML.
ðŸŸ¡ Add a --augment_all parameter to src/augment_yaml.py. Useful when adding new augmentations that need to be applied to all files.
The current augment_yaml.py uses the changelist from git to determine which files need augmentation.</description></item></channel></rss>