<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>en.cppreference.com on Chege's Blog</title><link>https://www.curiosities.dev/domains/en.cppreference.com/</link><description>Recent content in en.cppreference.com on Chege's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 01 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.curiosities.dev/domains/en.cppreference.com/index.xml" rel="self" type="application/rss+xml"/><item><title>User-Defined Types</title><link>https://www.curiosities.dev/computer-science/programming-challenges/language-concepts/type-systems/user-defined-types/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/language-concepts/type-systems/user-defined-types/</guid><description>Definition from C++ Built-in types are ones that can be built from the fundamental types (e.g. void, std::nullptr_t, int, bool, char, float, double ), the const modifier, and the declarator operators (e.g. int[3], int*, int&amp;amp;).
While the built-in types directly and efficiently represent the capabilities of conventional computer hardware, they&amp;rsquo;re too low-level to conveniently write advanced applications in. C++ abstraction mechanisms let programmers design and implement user-defined types using both built-in types and other user-defined types.</description></item><item><title>AoC 2021 Day 09: Smoke Basin</title><link>https://www.curiosities.dev/computer-science/programming-challenges/advent-of-code/2021/src/AoC2021/SmokeBasin/</link><pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/advent-of-code/2021/src/AoC2021/SmokeBasin/</guid><description>Multi-dimensional arrays using &lt;code>massiv&lt;/code>; Fusion; Box vs. Unboxed; Connected Components; &lt;code>Data.Set&lt;/code>; Monadic map</description></item><item><title>Classes in C++</title><link>https://www.curiosities.dev/computer-science/programming-challenges/language-concepts/type-systems/user-defined-types/classes-in-cpp/</link><pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/language-concepts/type-systems/user-defined-types/classes-in-cpp/</guid><description>quotes Doug McIlroy:
Those types are not &amp;ldquo;abstract&amp;rdquo;; they are as real as int and float.
What is the context of this quote?
A class is a user-defined type provided to represent a concept in the code of a program. Essentially, all language facilities beyond the fundamental types, operators, and statements exist to help define better class or to use them more conveniently.</description></item><item><title>Enumerations in C++</title><link>https://www.curiosities.dev/computer-science/programming-challenges/language-concepts/type-systems/user-defined-types/enumerations-in-cpp/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/language-concepts/type-systems/user-defined-types/enumerations-in-cpp/</guid><description>Unscoped (or Plain or C-Style) Enumerations Plain (or C-style) enums are entered in the same scope as the name of their enum, and implicitly convert to their integer value, e.g.
enum Color { red, green, blue }; int col = green; Color c2 = 1; // error: invalid conversion from &amp;#39;int&amp;#39; to &amp;#39;Color&amp;#39; [-fpermissive] enum CardColor { red, black }; // Error: &amp;#34;red&amp;#34; conflicts with a previous declaration</description></item><item><title>Sorting and Searching</title><link>https://www.curiosities.dev/computer-science/programming-challenges/leet-code-and-others/sorting-and-searching/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/leet-code-and-others/sorting-and-searching/</guid><description>Order Statistics K-th Smallest Element in Sorted Matrix Given an \(N \times N\) matrix, where each of the rows and columns are sorted in ascending order, return the \(k^{th}\) smallest element in the matrix. The memory complexity must be better than \(O(N^2)\).
It&amp;rsquo;s not guaranteed that matrix[r][c] &amp;gt; matrix[r-1][c], so we can&amp;rsquo;t compute the row (and similarly, the column) in which the \(k^{th}\) smallest element is in.
Using a priority queue that holds the \(K\) smallest elements does not work because the memory usage is \(O(K)\), where \(K\) can be any value in \([1, N^2]\).</description></item><item><title>Spanning 4-Directional Walks From Origin to Destination w/ Obstacles</title><link>https://www.curiosities.dev/computer-science/programming-challenges/leet-code-and-others/grids/4-directional-spanning-walks-with-obstacles/</link><pubDate>Sun, 31 Jul 2022 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/leet-code-and-others/grids/4-directional-spanning-walks-with-obstacles/</guid><description>Problem Given an \(M \times N\) integer array grid where grid[i][j] could be:
1 representing the starting square. There is exactly one starting square. 2 representing the ending square. There is exactly one ending square. 0 representing empty squares that we can walk over. -1 representing obstacles that we cannot walk over. Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</description></item><item><title>Templates in C++</title><link>https://www.curiosities.dev/computer-science/programming-challenges/language-concepts/parameterization/templates-cpp/</link><pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/language-concepts/parameterization/templates-cpp/</guid><description>A template is a class or a function that we can parameterize with a set of types or values.
Parameterized Types The vector-of-doubles can be generalized to a vector-of-anything type by making it a template:
// `template&amp;lt;typename T&amp;gt;` can be read as &amp;#34;for all types T&amp;#34;. Older code // uses `template&amp;lt;class T&amp;gt;`, which is equivalent. template&amp;lt;typename T&amp;gt; class Vector { public: explicit Vector(int s); ~Vector() { delete[] elem; } // .</description></item></channel></rss>