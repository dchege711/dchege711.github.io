"""

music_chart.py

Keeps track of my top songs as provided by LastFM

"""

import os
import sqlite3
import json
from datetime import date
import re
import fileinput

import requests

BASE_URL = "http://ws.audioscrobbler.com/2.0/"
APP_NAME = os.environ["LAST_FM_APP_NAME"]
API_KEY = os.environ["LAST_FM_API_KEY"]
USERNAME = os.environ["LAST_FM_USERNAME"]
LAST_FM_PREFIX = "https://www.last.fm/music/"
BASE_PATH = "/Users/dchege711/dchege711.github.io"
OUTPUT_HTML_FILEPATH = f"{BASE_PATH}/notebooks/_autogenerated/top-10-tracks.html"

conn = sqlite3.connect(f"{BASE_PATH}/src/music/c13u_music.db")
conn.row_factory = sqlite3.Row

def initialize_db():
    """
    Initialize the database if it hasn't been configured yet.
    """

    # conn.execute("DROP TABLE IF EXISTS tracks;")
    # conn.execute("DROP TABLE IF EXISTS artists;")

    conn.execute((
        "CREATE TABLE IF NOT EXISTS tracks ( "
        "track_id TEXT PRIMARY KEY, artist_id TEXT, image_url TEXT, date_modified VARCHAR(255), "
        "track_name TEXT, rank INT, rank_delta INT, music_brains_id VARCHAR(255));"
    ))

    conn.execute((
        "CREATE TABLE IF NOT EXISTS artists ( "
        "artist_id TEXT PRIMARY KEY, artist_name TEXT, "
        "music_brains_id VARCHAR(255));"
    ))

def fetch_top_tracks():
    """
    Fetch the top tracks over the past 7 days

    @returns List[dict] keyed by `name`, `duration`, `playcount`, `mbid`, `url`, 
    `streamable`, `artist`, `image`, `@attr`

    """
    with requests.Session() as sess:
        sess.headers.update({"user-agent": APP_NAME})
        get_params = {
            "method": "user.gettoptracks", "user": USERNAME, "period": "7day",
            "api_key": API_KEY, "limit": 600, "format": "json"
        }
        tracks = []
        while True:
            res_json = sess.get(BASE_URL, params=get_params).json()
            tracks += res_json["toptracks"]["track"]
            metadata = res_json["toptracks"]["@attr"]
            if int(metadata["page"]) < int(metadata["totalPages"]):
                get_params["page"] = int(metadata["page"]) + 1
            else:
                break

        return tracks

def persist_tracks(tracks):
    """
    Save the tracks into the database.
    """
    today_str = date.today().strftime("%Y-%m-%d")

    for track in tracks:
        # Last FM discontinued this service
        # https://getsatisfaction.com/lastfm/topics/api-announcement-dac8oefw5vrxq
        # try: image_url = track["image"][-1]["#text"]
        # except IndexError: image_url = ""

        track["track_id"] = track["url"].replace(LAST_FM_PREFIX, "")
        track["artist_id"] = track["artist"]["url"].replace(LAST_FM_PREFIX, "")
        track["image_url"] = None
        track["track_name"] = track["name"]
        track["rank"] = track["@attr"]["rank"]
        track["music_brains_id"] = track["mbid"]
        track["date_modified"] = today_str
        existing_row = conn.execute(
            "SELECT * FROM tracks WHERE track_id = ?", [track["track_id"]]
        ).fetchone()

        if existing_row is None:
            conn.execute(
                (
                    "INSERT INTO tracks (track_id, artist_id, image_url, track_name, "
                    "rank, music_brains_id, date_modified) VALUES (:track_id, :artist_id, "
                    ":image_url, :track_name, :rank, :music_brains_id, :date_modified);"
                ),
                track
            )
        else:
            track["rank_delta"] = existing_row["rank"] - int(track["rank"])
            conn.execute(
                (
                    "UPDATE tracks "
                    "SET rank_delta = :rank_delta, date_modified = :date_modified, rank = :rank "
                    "WHERE track_id = :track_id;"
                ),
                track
            )

        conn.execute(
            (
                "INSERT INTO artists (artist_id, artist_name, music_brains_id) "
                "VALUES (?, ?, ?) ON CONFLICT DO NOTHING;"
            ),
            [track["artist_id"], track["artist"]["name"], track["artist"]["mbid"]]
        )

    conn.execute(
        "DELETE FROM tracks WHERE date_modified != ?", [today_str]
    )

    conn.commit()

def dump_top_tracks(k=10):
    """Write the top ``k`` tracks to a JSON file."""
    res = conn.execute(
        (
            "SELECT track_id, track_name, tracks.artist_id, artist_name, rank, rank_delta "
            "FROM tracks, artists WHERE tracks.artist_id = artists.artist_id AND "
            "rank <= ? ORDER BY rank ASC;"
        ), [k]
    )
    tracks = [dict(**x) for x in res.fetchall()]
    for track in tracks:
        track["last_fm_track_url"] = "".join([LAST_FM_PREFIX, track["track_id"]])
        track["last_fm_artist_url"] = "".join([LAST_FM_PREFIX, track["artist_id"]])

    with open(f"{BASE_PATH}/_data/top_songs.json", "w") as output_file:
        json.dump(tracks, output_file, indent=2)

    # Write today's date on the .html file so that the blog updates
    # Don't change the name of the file though as that changes the permalink
    date_regex = re.compile(r"date: \d{4}-\d{2}-\d{2}")
    with fileinput.input(files=[OUTPUT_HTML_FILEPATH], inplace=True) as fp:
        found_match = False
        for line in fp:
            if not found_match and date_regex.match(line):
                print(f"date: {date.today().strftime('%Y-%m-%d')}\n", end="")
                found_match = True
            else:
                print(line, end="")

if __name__ == "__main__":
    # Run this script at most once per day
    last_mod_date = date.fromtimestamp(os.path.getmtime(OUTPUT_HTML_FILEPATH))
    today = date.today()
    if last_mod_date < today:
        initialize_db()
        tracks = fetch_top_tracks()
        persist_tracks(tracks)
        dump_top_tracks()
        print("Processed", len(tracks), "tracks for this week...")
    else:
        print("Already updated today's top 10 tracks...")
