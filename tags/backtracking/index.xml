<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>backtracking on Chege's Blog</title><link>https://www.curiosities.dev/tags/backtracking/</link><description>Recent content in backtracking on Chege's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 31 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.curiosities.dev/tags/backtracking/index.xml" rel="self" type="application/rss+xml"/><item><title>Spanning 4-Directional Walks From Origin to Destination w/ Obstacles</title><link>https://www.curiosities.dev/computer-science/programming-challenges/leet-code-and-others/grids/4-directional-spanning-walks-with-obstacles/</link><pubDate>Sun, 31 Jul 2022 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/leet-code-and-others/grids/4-directional-spanning-walks-with-obstacles/</guid><description>Problem Given an \(M \times N\) integer array grid where grid[i][j] could be:
1 representing the starting square. There is exactly one starting square. 2 representing the ending square. There is exactly one ending square. 0 representing empty squares that we can walk over. -1 representing obstacles that we cannot walk over. Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</description></item></channel></rss>