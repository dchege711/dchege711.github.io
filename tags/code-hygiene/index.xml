<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>code-hygiene on Chege&#39;s Blog</title>
    <link>https://www.curiosities.dev/tags/code-hygiene/</link>
    <description>Recent content in code-hygiene on Chege&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 28 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.curiosities.dev/tags/code-hygiene/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43; Meta-Programming</title>
      <link>https://www.curiosities.dev/computer-science/programming-challenges/language-concepts/meta-programming/cpp-metaprogramming/</link>
      <pubDate>Mon, 28 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.curiosities.dev/computer-science/programming-challenges/language-concepts/meta-programming/cpp-metaprogramming/</guid>
      <description>Clang, LLVM, GCC, and MSVC LLVM is an umbrella project, with several sub-projects, e.g. LLVM Core and Clang. LLVM Core libraries provide an optimizer and code generator for different CPUs. Clang is an &amp;ldquo;LLVM native&amp;rdquo; C/C++/Objective-C compiler which aims for fast compilation, useful error and warning messages, and a platform for building source-level tools. The Clang Static Analyzer and clang-tidy are examples of such tools. 
So if I were to create a programming language, I can define a transformation into LLVM intermediate representation (LLVM IR), and that will make use of LLVM core to optimize it?</description>
    </item>
    
    <item>
      <title>Of Code Smells and Hygiene</title>
      <link>https://www.curiosities.dev/computer-science/miscellaneous/2020-07-05-code-smells-and-hygiene/</link>
      <pubDate>Sun, 05 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.curiosities.dev/computer-science/miscellaneous/2020-07-05-code-smells-and-hygiene/</guid>
      <description>Pick up from:
 IEEE&amp;rsquo;s International Conference on Software Maintenance     Improving Code: The (Mis)perception of Quality Metrics      Springer&amp;rsquo;s Software Quality Journal       On Abstractions If you find yourself adding more parameters and if-statements to an existing abstraction, is the abstraction still apt? Why not remove the old abstraction and re-extract a new [more apt] abstraction? Devs frequently succumb to the sunken cost fallacy thinking that there must have been a reason that the code was written in a certain way.</description>
    </item>
    
  </channel>
</rss>
