<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design Patterns: Elements of Reusable Object-Oriented Software on Chege's Blog</title><link>https://www.curiosities.dev/computer-science/gang-of-four-design-patterns/</link><description>Recent content in Design Patterns: Elements of Reusable Object-Oriented Software on Chege's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 21 Oct 1994 00:00:00 +0000</lastBuildDate><atom:link href="https://www.curiosities.dev/computer-science/gang-of-four-design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Intro to Design Patterns</title><link>https://www.curiosities.dev/computer-science/gang-of-four-design-patterns/intro-to-design-patterns/</link><pubDate>Thu, 30 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/gang-of-four-design-patterns/intro-to-design-patterns/</guid><description>What Are Design Patterns? Arriving at designs that are specific to the problem at hand but general enough to address future problems and requirements is hard. New designers tend to be overwhelmed by the options available. Expert designers do not solve every problem from first principles; they reuse design patterns.
I&amp;rsquo;ve also encountered the &amp;ldquo;you aren&amp;rsquo;t gonna need it&amp;rdquo; (YAGNI) school of thought that aims to minimize writing code that anticipates too far into the future, as such guesses usually don&amp;rsquo;t pan out.</description></item></channel></rss>