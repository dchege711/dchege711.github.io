<!doctype html><html lang=en><head><title>Unique Paths to the Bottom-Right Corner | curiosities.dev</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo (https://gohugo.io/)"><meta name=description content="Problem Starting from the top-left corner, what is the number of possible unique paths to reach the bottom-right corner, if you can only move either down or right at any point in time? 
Dynamic Programming Solution for Moving Down/Right #dynamic-programming
The number of unique paths to grid[r][c] is the number of unique paths to grid[r-1][c] plus the number of unique paths to grid[r][c-1].
At any given time, we&rsquo;re interested in two adjacent rows, so our space usage should be at most \(2n\)...."><link rel=stylesheet type=text/css href=/css/main.min.css><link rel=preload href=/css/all_font_awesome_v5.9.min.min.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=/css/all_font_awesome_v5.9.min.min.css></noscript><link rel="shortcut icon" href=/img/favicon_io/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/img/favicon_io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/img/favicon_io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon_io/favicon-16x16.png><script async type=text/javascript src=/js/OrganizeCitations.min.js></script><script async type=text/javascript src=/js/HighlightAnchor.min.js></script><script async type=text/javascript src=/js/SummaryPageUtils.min.js></script><link rel=preload href=/css/vs.min.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=/css/vs.min.css></noscript><script defer type=text/javascript src=/js/highlight.min.min.js onload=addURLHighlighter();></script><script defer>const hjlsURLRegex=/https?:\/\/[^\s<]+/g
const hjlsCitationRegex=/&lt;span class=&quot;citation-ref&quot;&gt;&lt;a href=&quot;(.*)&quot;&gt;&lt;\/a&gt;&lt;\/span&gt;/g
function addURLHighlighter(){hljs.addPlugin({"after:highlight":(result)=>{result.value=result.value.replaceAll(hjlsURLRegex,"<a href='$&' target='_blank'>$&</a>");console.log(result.value);result.value=result.value.replaceAll(hjlsCitationRegex,"<span class='citation-ref'><a href='$1'></a></span>");}});hljs.highlightAll();}</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script></head><body><div class=container id=main_div><form action=/search method=get id=globalSearchForm><input type=text id=q name=q title="Search Query">
<input type=submit id=submitButton value=Search></form><nav aria-label=Breadcrumb class=breadcrumb><ul><li><a href=https://www.curiosities.dev/>Home</a></li><li><a href=https://www.curiosities.dev/computer-science/>Computer Science & Software Engineering</a></li><li><a href=https://www.curiosities.dev/computer-science/programming-challenges/>Programming Challenges</a></li><li><a href=https://www.curiosities.dev/computer-science/programming-challenges/leet-code-and-others/>Leet Code Style Questions</a></li><li><a href=https://www.curiosities.dev/computer-science/programming-challenges/leet-code-and-others/grids/>Grids</a></li><li class=active><a href=https://www.curiosities.dev/computer-science/programming-challenges/leet-code-and-others/grids/unique-down-right-paths/>Unique Paths to the Bottom-Right Corner</a></li></ul></nav><section><header><h1>Unique Paths to the Bottom-Right Corner</h1><p class=meta>Dated Jul 30, 2022;
last modified on Sat, 30 Jul 2022</p></header><div id=toc-then-article><aside id=toc><nav id=TableOfContents><ul><li><a href=#problem>Problem</a></li><li><a href=#dynamic-programming-solution-for-moving-downright>Dynamic Programming Solution for Moving Down/Right</a></li><li><a href=#combinatorics-solution-for-moving-downright>Combinatorics Solution for Moving Down/Right</a></li><li><a href=#takeaways>Takeaways</a></li><li><a href=#references>References</a></li></ul></nav></aside><article id=main-article><h2 id=problem>Problem</h2><p>Starting from the top-left corner, what is the number of possible unique
paths to reach the bottom-right corner, if you can only move either down
or right at any point in time? <span class=citation-ref><a href=#LCUniquePaths></a></span></p><h2 id=dynamic-programming-solution-for-moving-downright>Dynamic Programming Solution for Moving Down/Right</h2><p><span class=tag-ref><a href=/tags/dynamic-programming>#dynamic-programming</a></span></p><p>The number of unique paths to <code>grid[r][c]</code> is the number of unique paths
to <code>grid[r-1][c]</code> plus the number of unique paths to <code>grid[r][c-1]</code>.</p><p>At any given time, we&rsquo;re interested in two adjacent rows, so our space
usage should be at most \(2n\). Furthermore, we do not back-track to
the left, so if we update our values left-to-right, we can use \(n\)
space.</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=color:#00a8c8>int</span> <span style=color:#75af00>uniquePaths</span><span style=color:#111>(</span><span style=color:#00a8c8>int</span> <span style=color:#111>m</span><span style=color:#111>,</span> <span style=color:#00a8c8>int</span> <span style=color:#111>n</span><span style=color:#111>)</span> <span style=color:#111>{</span>
  <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#111>m</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#111>n</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span><span style=color:#111>)</span> <span style=color:#00a8c8>return</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span>

  <span style=color:#111>std</span><span style=color:#f92672>::</span><span style=color:#111>vector</span><span style=color:#f92672>&lt;</span><span style=color:#00a8c8>int</span><span style=color:#f92672>&gt;</span> <span style=color:#111>numPathsToPosition</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>,</span> <span style=color:#ae81ff>0</span><span style=color:#111>);</span>
  <span style=color:#111>numPathsToPosition</span><span style=color:#111>[</span><span style=color:#ae81ff>0</span><span style=color:#111>]</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#111>;</span>

  <span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#00a8c8>int</span> <span style=color:#111>r</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>r</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>m</span><span style=color:#111>;</span> <span style=color:#f92672>++</span><span style=color:#111>r</span><span style=color:#111>)</span> <span style=color:#111>{</span>
    <span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#00a8c8>int</span> <span style=color:#111>c</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>c</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>n</span><span style=color:#111>;</span> <span style=color:#f92672>++</span><span style=color:#111>c</span><span style=color:#111>)</span> <span style=color:#111>{</span>
      <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#00a8c8>int</span> <span style=color:#111>nextC</span> <span style=color:#f92672>=</span> <span style=color:#111>c</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#111>;</span> <span style=color:#111>nextC</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>n</span><span style=color:#111>)</span> <span style=color:#111>{</span>
          <span style=color:#111>numPathsToPosition</span><span style=color:#111>[</span><span style=color:#111>nextC</span><span style=color:#111>]</span> <span style=color:#f92672>+=</span> <span style=color:#111>numPathsToPosition</span><span style=color:#111>[</span><span style=color:#111>c</span><span style=color:#111>];</span>
      <span style=color:#111>}</span>
    <span style=color:#111>}</span>
  <span style=color:#111>}</span>

  <span style=color:#00a8c8>return</span> <span style=color:#111>numPathsToPosition</span><span style=color:#111>[</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>];</span>
<span style=color:#111>}</span>
</code></pre></div><p>The above solution is pretty fast for <span class=citation-ref><a href=#LCUniquePaths></a></span>&rsquo;s
online judge, so the runtime (less than 5ms) is not comparable. The
runtime is \(O(m n)\).</p><p>The memory usage is \(O(n)\). Per <span class=citation-ref><a href=#LCUniquePaths></a></span>, that&rsquo;s
\(\approx\) 6MB which is better than 63% of submissions. The range is
5,400 KB to 6,500 KB, so all submissions within an order of magnitude of
each other.</p><div class=comment-holder><div class=comment><p>The answer is guaranteed to be \(\le 2 \cdot 10^9 = 2^{lg(2 \cdot
10^9)} &lt; 2^{31}\). The <code>int</code> data type is guaranteed to be at least 16
bits, but on 32/64 bit systems, it&rsquo;s almost guaranteed to be at least 32
bits wide <span class=citation-ref><a href=#cppReferenceFundamentalTypes></a></span>. I can specify
<code>std:uint32_t</code> from <code>&lt;cstdint></code> to be sure that a 32-bit representation
is used <span class=citation-ref><a href=#cppReferenceFixWidthIntegerTypes></a></span>.</p><p><code>std:uint32_t</code> is unlikely to improve the space usage as I don&rsquo;t see
solutions that use 3MB. It&rsquo;s more likely that LeetCode&rsquo;s environment
uses 32-bit <code>int</code>s. Update: no improvement, both <code>sizeof(int)</code> and
<code>sizeof(std::uint32_t)</code> evaluate to <code>4</code> bytes (and therefore 32 bits).</p></div></div><h2 id=combinatorics-solution-for-moving-downright>Combinatorics Solution for Moving Down/Right</h2><p><span class=tag-ref><a href=/tags/combinatorics>#combinatorics</a></span></p><p><span class=citation-ref><a href=#Archit91LCUniquePaths></a></span>models the problem as a combinatorics
problem: to get to the bottom-right, we need to choose \(m - 1\) right
moves and \(n - 1\) down moves, from a total of \(m + n - 2\) moves.</p><p>$$ C_{m-1}^{m+n-2} = C_{n-1}^{m+n-2} = \frac{(m+n-2)!}{(m-1)!(n-1)!} $$</p><div class=comment-holder><div class=comment><p>Why is \(C_{m-1}^{m+n-2} = C_{n-1}^{m+n-2}\) true? In general,
\(C^{n}_{k} = \frac{n!}{k!(n-k)!}\), and so this follows
algebraically. It&rsquo;s not a special property of the problem.</p></div></div><p>Assuming \(m > n\) in order to eliminate \((m-1)!\) gives us:</p><p>$$ C_{m-1}^{m+n-2} = \frac{(m+n-2) \times (m+n-3) \times &mldr; \times (m+n-n) \times (m-1) \times &mldr; \times 1 }{ ((m-1) \times (m-2) \times &mldr; \times 1) (n-1)!} $$
$$ = \frac{(m+n-2) \times (m+n-3) \times &mldr; \times m}{(n-1)!} $$</p><div class=comment-holder><div class="comment open-comment"><p>How is the above guaranteed to be an integer?</p><p>By definition, \(C^{n}_{k}\) counts something, and therefore it&rsquo;s an
integer. <span class=citation-ref><a href=#SECombinationIsAnInteger></a></span></p><p>From <span class=citation-ref><a href=#proofWikiBinomialCoefficientInteger></a></span>:</p><p>$$ C^{n}_{k} = \binom{n}{k} = \frac{n}{k!(n-k)!} $$
$$ = \frac{n (n-1) (n-2) &mldr; (n - k + 1)}{k!} $$</p><p>&mldr; the numerator is a product of \(k\) successive integers, and <span class=citation-ref><a href=#proofWikiBFactorialDividesProductOfSuccessiveNumbers></a></span>(whose
proof is beyond my mathematical maturity) states that the factorial of
\(k\) divides the product of \(k\) successive numbers.</p><p>The mathematical aspect is settled, but why does the code before work
without running into precision errors? Shouldn&rsquo;t we first compute the
numerator, and then divide out the denominator? Dividing integral types
is pretty bad as it truncates the result.</p><p>The largest numerator possible is when \(m = 100, n = 100\), which is
\(198 \cdot 197 \cdot &mldr; \cdot 100 = \frac{198!}{99!} &lt; 2^{712}\).
The largest ints in <span class=citation-ref><a href=#cppReferenceFundamentalTypes></a></span>are 64
bits wide, and thus too small to hold \(2^{712}\). <code>long double</code>&rsquo;s max
is \(1.18973 \cdot 10^{4932}\), which can hold \(2^{712} &lt; 2.155
\cdot 10^{214}\), but with loss of precision. To use a <code>long double</code>
without losing precision, then we&rsquo;re limited by <code>LDBL_MANT_DIG</code>, which
is typically <code>64</code>, and thus not better than the biggest <code>int</code> from the
standard library. <span class=citation-ref><a href=#cppReferenceNumericLimits></a></span></p><p>Maybe the takeaway is that if you&rsquo;re worried about large numbers
(factorials and such), use a language that natively supports
infinite-precision arithmetic, e.g. Python?</p></div></div><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=color:#00a8c8>int</span> <span style=color:#75af00>unique_paths</span><span style=color:#111>(</span><span style=color:#00a8c8>int</span> <span style=color:#111>m</span><span style=color:#111>,</span> <span style=color:#00a8c8>int</span> <span style=color:#111>n</span><span style=color:#111>)</span> <span style=color:#111>{</span>
  <span style=color:#00a8c8>long</span> <span style=color:#111>num_combinations</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#111>;</span>
  <span style=color:#00a8c8>const</span> <span style=color:#00a8c8>int</span> <span style=color:#111>m_prime</span> <span style=color:#f92672>=</span> <span style=color:#111>max</span><span style=color:#111>(</span><span style=color:#111>m</span><span style=color:#111>,</span> <span style=color:#111>n</span><span style=color:#111>);</span>
  <span style=color:#75715e>// Because m&#39; &gt; n&#39;, when `num &lt;= m&#39;` all of the values in [1, n&#39;) will
</span><span style=color:#75715e></span>  <span style=color:#75715e>// have been visited by the loop.
</span><span style=color:#75715e></span>  <span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#00a8c8>int</span> <span style=color:#111>num</span> <span style=color:#f92672>=</span> <span style=color:#111>m</span> <span style=color:#f92672>+</span> <span style=color:#111>n</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span><span style=color:#111>,</span> <span style=color:#111>denom</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#111>;</span> <span style=color:#111>num</span> <span style=color:#f92672>&gt;=</span> <span style=color:#111>m_prime</span><span style=color:#111>;</span> <span style=color:#f92672>--</span><span style=color:#111>num</span><span style=color:#111>,</span> <span style=color:#f92672>++</span><span style=color:#111>denom</span><span style=color:#111>)</span> <span style=color:#111>{</span>
    <span style=color:#111>num_combinations</span> <span style=color:#f92672>*=</span> <span style=color:#111>num</span><span style=color:#111>;</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#111>denom</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>n</span><span style=color:#111>)</span> <span style=color:#111>num_combinations</span> <span style=color:#f92672>/=</span> <span style=color:#111>denom</span><span style=color:#111>;</span>
  <span style=color:#111>}</span>
  <span style=color:#00a8c8>return</span> <span style=color:#111>num_combinations</span><span style=color:#111>;</span>
<span style=color:#111>}</span>
</code></pre></div><p>Re-ordering \(m, n\), such that \(m\) is the max, the loop goes
through \(m + n - 2 - m = n - 2\) iterations, and therefore the
runtime is \(O(min(m, n))\). The space usage is \(O(1)\). I don&rsquo;t
think we can do better than this.</p><div class=comment-holder><div class=comment><p>Curiously, the space usage for the combinatorics approach is 5.9MB. I
thought it&rsquo;d be much lower than the 6MB used in the DP solution. On
second thought, the DP solution uses \(O(n)\) space, and the problem
is defined such that \(n \le 100\), which is close to \(O(1)\).</p></div></div><h2 id=takeaways>Takeaways</h2><p>I was wrong to earlier assume that because other people&rsquo;s solutions were
within one magnitude of 6MB, the DP solution was the optimal one.
Sometimes \(n\) is too small to distinguish between optimal and
sub-optimal solutions.</p><p>The regularity of the problem (well-defined grid; only moving
right/down) should hint at a (probably optimal) math-based answer.</p><h2 id=references>References</h2><ol><li><div class=citation citation-icon-class="fas fa-fw fa-globe" cited-by-count is-main><cite id=LCUniquePaths>Unique Paths (Medium) - LeetCode<i>.</i></cite>
<a href=https://leetcode.com/problems/unique-paths/ target=_blank rel=noopener><img src="https://www.google.com/s2/favicons?domain=leetcode.com" loading=lazy aria-hidden=true width=16 height=16>
<i>leetcode.com</i> <i class="fas fa-fw fa-external-link-alt" aria-hidden=true></i></a>.
<a href=https://leetcode.com/submissions/detail/761078821/ target=_blank rel=noopener><img src="https://www.google.com/s2/favicons?domain=leetcode.com" loading=lazy aria-hidden=true width=16 height=16>
<i>leetcode.com</i> <i class="fas fa-fw fa-external-link-alt" aria-hidden=true></i></a>.
<a href=https://leetcode.com/submissions/detail/761262306/ target=_blank rel=noopener><img src="https://www.google.com/s2/favicons?domain=leetcode.com" loading=lazy aria-hidden=true width=16 height=16>
<i>leetcode.com</i> <i class="fas fa-fw fa-external-link-alt" aria-hidden=true></i></a>.
<i class="fas fa-fw fa-globe" aria-hidden=true></i>Accessed Jul 30, 2022.</div></li><li><div class=citation citation-icon-class="fas fa-fw fa-globe" cited-by-count is-main><cite id=cppReferenceFundamentalTypes>Fundamental types - cppreference.com<i>.</i></cite>
<a href=https://en.cppreference.com/w/cpp/language/types target=_blank rel=noopener><img src="https://www.google.com/s2/favicons?domain=en.cppreference.com" loading=lazy aria-hidden=true width=16 height=16>
<i>en.cppreference.com</i> <i class="fas fa-fw fa-external-link-alt" aria-hidden=true></i></a>.
<i class="fas fa-fw fa-globe" aria-hidden=true></i>Accessed Jul 30, 2022.</div></li><li><div class=citation citation-icon-class="fas fa-fw fa-globe" cited-by-count is-main><cite id=cppReferenceFixWidthIntegerTypes>Fixed width integer types (since C++11) - cppreference.com<i>.</i></cite>
<a href=https://en.cppreference.com/w/cpp/types/integer target=_blank rel=noopener><img src="https://www.google.com/s2/favicons?domain=en.cppreference.com" loading=lazy aria-hidden=true width=16 height=16>
<i>en.cppreference.com</i> <i class="fas fa-fw fa-external-link-alt" aria-hidden=true></i></a>.
<i class="fas fa-fw fa-globe" aria-hidden=true></i>Accessed Jul 30, 2022.</div></li><li><div class=citation citation-icon-class="fas fa-fw fa-globe" cited-by-count is-main><cite id=Archit91LCUniquePaths>âœ… [C++/Python] 5 Simple Solutions w/ Explanation | Optimization from Brute-Force to DP to Math - LeetCode Discuss<i>.</i></cite>
<a href=https://leetcode.com/problems/unique-paths/discuss/1581998/C%2B%2BPython-4-Simple-Solutions-w-Explanation-or-Optimization-from-Brute-Force-to-DP-to-Math target=_blank rel=noopener><img src="https://www.google.com/s2/favicons?domain=leetcode.com" loading=lazy aria-hidden=true width=16 height=16>
<i>leetcode.com</i> <i class="fas fa-fw fa-external-link-alt" aria-hidden=true></i></a>.
<i class="fas fa-fw fa-globe" aria-hidden=true></i>Accessed Jul 30, 2022.</div></li><li><div class=citation citation-icon-class="fas fa-fw fa-globe" cited-by-count is-main><cite id=SECombinationIsAnInteger>elementary number theory - Proof that a Combination is an integer - Mathematics Stack Exchange<i>.</i></cite>
<a href=https://math.stackexchange.com/questions/11601/proof-that-a-combination-is-an-integer target=_blank rel=noopener><img src="https://www.google.com/s2/favicons?domain=math.stackexchange.com" loading=lazy aria-hidden=true width=16 height=16>
<i>math.stackexchange.com</i> <i class="fas fa-fw fa-external-link-alt" aria-hidden=true></i></a>.
<i class="fas fa-fw fa-globe" aria-hidden=true></i>Accessed Jul 31, 2022.</div></li><li><div class=citation citation-icon-class="fas fa-fw fa-globe" cited-by-count is-main><cite id=proofWikiBinomialCoefficientInteger>Binomial Coefficient is Integer - ProofWiki<i>.</i></cite>
<a href=https://proofwiki.org/wiki/Binomial_Coefficient_is_Integer target=_blank rel=noopener><img src="https://www.google.com/s2/favicons?domain=proofwiki.org" loading=lazy aria-hidden=true width=16 height=16>
<i>proofwiki.org</i> <i class="fas fa-fw fa-external-link-alt" aria-hidden=true></i></a>.
<i class="fas fa-fw fa-globe" aria-hidden=true></i>Accessed Jul 31, 2022.</div></li><li><div class=citation citation-icon-class="fas fa-fw fa-globe" cited-by-count is-main><cite id=proofWikiBFactorialDividesProductOfSuccessiveNumbers>Factorial Divides Product of Successive Numbers - ProofWiki<i>.</i></cite>
<a href=https://proofwiki.org/wiki/Factorial_Divides_Product_of_Successive_Numbers target=_blank rel=noopener><img src="https://www.google.com/s2/favicons?domain=proofwiki.org" loading=lazy aria-hidden=true width=16 height=16>
<i>proofwiki.org</i> <i class="fas fa-fw fa-external-link-alt" aria-hidden=true></i></a>.
<i class="fas fa-fw fa-globe" aria-hidden=true></i>Accessed Jul 31, 2022.</div></li><li><div class=citation citation-icon-class="fas fa-fw fa-globe" cited-by-count is-main><cite id=cppReferenceNumericLimits>std::numeric_limits - cppreference.com<i>.</i></cite>
<a href=https://en.cppreference.com/w/cpp/types/numeric_limits target=_blank rel=noopener><img src="https://www.google.com/s2/favicons?domain=en.cppreference.com" loading=lazy aria-hidden=true width=16 height=16>
<i>en.cppreference.com</i> <i class="fas fa-fw fa-external-link-alt" aria-hidden=true></i></a>.
<a href=https://en.cppreference.com/w/cpp/types/climits target=_blank rel=noopener><img src="https://www.google.com/s2/favicons?domain=en.cppreference.com" loading=lazy aria-hidden=true width=16 height=16>
<i>en.cppreference.com</i> <i class="fas fa-fw fa-external-link-alt" aria-hidden=true></i></a>.
<i class="fas fa-fw fa-globe" aria-hidden=true></i>Accessed Jul 31, 2022.</div></li></ol></article><div style=font-size:smaller></div></div><footer><a href=https://www.curiosities.dev/computer-science/programming-challenges/leet-code-and-others/grids/4-directional-spanning-walks-with-obstacles/>Spanning 4-Directional Walks From Origin to Destination w/ Obstacles &#187;</a></footer></section></div><footer><a href=mailto:d.chege711@gmail.com>Email</a>
<a href=/about>About</a>
<a href=/search>Search</a></footer></body></html>