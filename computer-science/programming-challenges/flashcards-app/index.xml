<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Flashcards App on Chege's Blog</title><link>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/</link><description>Recent content in Flashcards App on Chege's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 27 Mar 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/index.xml" rel="self" type="application/rss+xml"/><item><title>Testing in a Monorepo</title><link>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/testing/</link><pubDate>Sat, 22 Jun 2024 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/testing/</guid><description>Choosing web-test-runner as the Client Test Framework While any test framework can work, it&amp;rsquo;s better to test web components in a browser environment because that&amp;rsquo;s where they&amp;rsquo;ll be used. Node-based frameworks would require too much shimming of DOM calls that&amp;rsquo;d make the tests unrepresentative. and are good options for browser-based testing.
is powered by ES-build, and so is the client-side of the app; let&amp;rsquo;s go down this path and see where it leads.</description></item><item><title>Database Layer</title><link>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/database-layer/</link><pubDate>Sun, 16 Jun 2024 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/database-layer/</guid><description>Currently using MongoDB&amp;rsquo;s free tier, which has shared RAM, and up to 5GB of storage . So far, the overall DB usage has been less than 5MB.
Query Injection Current State of Affairs Currently have this protection implemented back in 2018:
/** * @description Prevent a NoSQL Injection in the search parameters. This is * achieved by deleting all query values that begin with `$`. */ export function sanitizeQuery(query: any) { const keys = Object.</description></item><item><title>Continuous Integration Tooling</title><link>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/ci-tooling/</link><pubDate>Sun, 09 Jun 2024 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/ci-tooling/</guid><description>What automatic tools can I add to keep code quality high?
CodeQL CodeQL is a tool that runs variant analysis on code. The idea is that we create a query from a known vulnerability, e.g., SQL injection, and then run it against a codebase to find instances of that vulnerability. GitHub authorizes the use of CodeQL for public repos, and so we are covered . ql-analysis.sh has a recipe for running the analysis locally in the repo.</description></item><item><title>Markup Features</title><link>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/markup-features/</link><pubDate>Sat, 27 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/markup-features/</guid><description>Syntax Highlighting Previously, we&amp;rsquo;d highlight code on the client by loading src/lib/highlight.pack.js, a bundle downloaded from but served from our domain, and then execute hljs.highlightBlock on demand, e.g., on page load, when showing a card, etc. This doesn&amp;rsquo;t work well with a web-component-centric design. Running hljs.highlightBlock through possible Shadow DOM boundaries is a hassle.
Back in 2018 , we installed highlightjs, a shim for the official HighlightJS.</description></item><item><title>Of Builds and Bundlers</title><link>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/of-builds-and-bundlers/</link><pubDate>Sat, 20 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/of-builds-and-bundlers/</guid><description>Moving to TypeScript entails configuring how the JavaScript will be eventually consumed by both the server and the client.
Separating the Client Bundle from the Server Bundle The server code runs in Node while the client code runs in the browser. advises separating the configurations for advantages like faster type-checking and compiling, lower memory usage when using an editor, and improved enforcement of the logical groupings of your program.</description></item><item><title>Client/Server Interface</title><link>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/client-server-interface/</link><pubDate>Fri, 19 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/client-server-interface/</guid><description>How to handle redirects without setting window.location.href? Right now, there&amp;rsquo;s a pattern of doing:
sendHTTPRequest(&amp;#34;POST&amp;#34;, &amp;#34;/login/&amp;#34;, {}) .then((_) =&amp;gt; { window.location.href = &amp;#34;/&amp;#34;; }) .catch((err) =&amp;gt; { console.error(err); }); Isn&amp;rsquo;t this something that the server can do? In response, why not issue a redirect?
Screenshot of the redirect chain from /login. The POST request gets a 303 (See Other) redirect to /home. The browser then makes a GET request to /home, which results in a 304 (Not Modified).</description></item><item><title>Use of Local Storage</title><link>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/use-of-local-storage/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/use-of-local-storage/</guid><description>Back when I wrote this, the motivation for using localStorage was to reduce the trips to the server so that the app is usable offline. However, with two data stores (localStorage and the server), the former has a possibility of going stale. What usage is correct and how can we avoid stale data?
localStorage['session_info'] getAccountInfo: () =&amp;gt; AuthenticateUser | null fetches the session_info entry and JSON.parses it into an AuthenticateUser. This is a possible failure point because the parsed JSON cannot be trusted to be a valid AuthenticateUser instance.</description></item><item><title>Hosting the Flashcards App</title><link>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/hosting/</link><pubDate>Wed, 27 Mar 2024 00:00:00 +0000</pubDate><guid>https://www.curiosities.dev/computer-science/programming-challenges/flashcards-app/hosting/</guid><description>Current State: SaaS The app is hosted at render.com on Render&amp;rsquo;s free tier that gives us these free web services:
Custom domains Managed TLS certificates Pull request reviews Log streams Rollbacks up to the two most recent previous deploys. &amp;hellip; with these limitations:
Spins down after 15min of no inbound traffic. Spinning up on the next request causes a noticeable delay for a couple seconds.</description></item></channel></rss>