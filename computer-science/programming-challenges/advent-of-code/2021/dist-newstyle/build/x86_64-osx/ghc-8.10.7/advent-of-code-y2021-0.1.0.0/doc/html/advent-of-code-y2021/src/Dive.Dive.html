<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# OPTIONS_GHC -Wall #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Dive.Dive</span><span>
</span><span id="line-4"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Dive.Dive.html#productOfFinalPosition"><span class="hs-identifier">productOfFinalPosition</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-5"></span><span>    </span><span class="annot"><a href="Dive.Dive.html#productOfFinalPositionWithNewIntepretation"><span class="hs-identifier">productOfFinalPositionWithNewIntepretation</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-6"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-7"></span><span class="hs-keyword">where</span><span>
</span><span id="line-8"></span><span>
</span><span id="line-9"></span><span class="hs-comment">-- One consideration in Haskell is the third-party library that I should use,</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- given that standard GHC seems quite lean. [1] should help in picking up</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- libraries that have lots of usage. For example, [2] helped me pick [3], which</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- uses Posix regex, and is fast, native, stable and lazy.</span><span>
</span><span id="line-13"></span><span class="hs-comment">--</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- [1]: https://wiki.haskell.org/Category:Libraries</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- [2]: https://wiki.haskell.org/Regular_expressions</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- [3]: https://hackage.haskell.org/package/regex-tdfa</span><span>
</span><span id="line-17"></span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">fromJust</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">isJust</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mapMaybe</span></span><span class="hs-special">)</span><span>
</span><span id="line-19"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Text.Read</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">readMaybe</span></span><span class="hs-special">)</span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Text.Regex.TDFA</span></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-operator">(=~)</span></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-21"></span><span>
</span><span id="line-22"></span><span class="hs-comment">-- [1] suggests that I should be fine without deriving from the `Enum` data</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- type. Deriving from `Enum` helps me when I care about the mapping to an</span><span>
</span><span id="line-24"></span><span class="hs-comment">-- underlying type, e.g. Int. [2]</span><span>
</span><span id="line-25"></span><span class="hs-comment">--</span><span>
</span><span id="line-26"></span><span class="hs-comment">-- [1]: https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/5-tokenizer-data-types#enumerated-data-types</span><span>
</span><span id="line-27"></span><span class="hs-comment">-- [2]: https://stackoverflow.com/questions/6000511/better-way-to-define-an-enum-in-haskell/6000520</span><span>
</span><span id="line-28"></span><span class="hs-comment">-- [3]: https://www.schoolofhaskell.com/school/starting-with-haskell/introduction-to-haskell/2-algebraic-data-types</span><span>
</span><span id="line-29"></span><span class="hs-keyword">data</span><span> </span><span id="DiveDirection"><span class="annot"><a href="Dive.Dive.html#DiveDirection"><span class="hs-identifier hs-var">DiveDirection</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Up"><span class="annot"><a href="Dive.Dive.html#Up"><span class="hs-identifier hs-var">Up</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="Down"><span class="annot"><a href="Dive.Dive.html#Down"><span class="hs-identifier hs-var">Down</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="Forward"><span class="annot"><a href="Dive.Dive.html#Forward"><span class="hs-identifier hs-var">Forward</span></a></span></span><span> </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679058201"><span id="local-6989586621679058203"><span class="annot"><span class="annottext">DiveDirection -&gt; DiveDirection -&gt; Bool
(DiveDirection -&gt; DiveDirection -&gt; Bool)
-&gt; (DiveDirection -&gt; DiveDirection -&gt; Bool) -&gt; Eq DiveDirection
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DiveDirection -&gt; DiveDirection -&gt; Bool
$c/= :: DiveDirection -&gt; DiveDirection -&gt; Bool
== :: DiveDirection -&gt; DiveDirection -&gt; Bool
$c== :: DiveDirection -&gt; DiveDirection -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679058194"><span id="local-6989586621679058196"><span id="local-6989586621679058198"><span class="annot"><span class="annottext">Int -&gt; DiveDirection -&gt; ShowS
[DiveDirection] -&gt; ShowS
DiveDirection -&gt; String
(Int -&gt; DiveDirection -&gt; ShowS)
-&gt; (DiveDirection -&gt; String)
-&gt; ([DiveDirection] -&gt; ShowS)
-&gt; Show DiveDirection
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DiveDirection] -&gt; ShowS
$cshowList :: [DiveDirection] -&gt; ShowS
show :: DiveDirection -&gt; String
$cshow :: DiveDirection -&gt; String
showsPrec :: Int -&gt; DiveDirection -&gt; ShowS
$cshowsPrec :: Int -&gt; DiveDirection -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-30"></span><span>
</span><span id="line-31"></span><span class="annot"><a href="Dive.Dive.html#diveDirection"><span class="hs-identifier hs-type">diveDirection</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Dive.Dive.html#DiveDirection"><span class="hs-identifier hs-type">DiveDirection</span></a></span><span>
</span><span id="line-32"></span><span id="diveDirection"><span class="annot"><span class="annottext">diveDirection :: String -&gt; Maybe DiveDirection
</span><a href="Dive.Dive.html#diveDirection"><span class="hs-identifier hs-var hs-var">diveDirection</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;forward&quot;</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DiveDirection -&gt; Maybe DiveDirection
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">DiveDirection
</span><a href="Dive.Dive.html#Forward"><span class="hs-identifier hs-var">Forward</span></a></span><span>
</span><span id="line-33"></span><span class="annot"><a href="Dive.Dive.html#diveDirection"><span class="hs-identifier hs-var">diveDirection</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;up&quot;</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DiveDirection -&gt; Maybe DiveDirection
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">DiveDirection
</span><a href="Dive.Dive.html#Up"><span class="hs-identifier hs-var">Up</span></a></span><span>
</span><span id="line-34"></span><span class="annot"><a href="Dive.Dive.html#diveDirection"><span class="hs-identifier hs-var">diveDirection</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;down&quot;</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DiveDirection -&gt; Maybe DiveDirection
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">DiveDirection
</span><a href="Dive.Dive.html#Down"><span class="hs-identifier hs-var">Down</span></a></span><span>
</span><span id="line-35"></span><span class="annot"><a href="Dive.Dive.html#diveDirection"><span class="hs-identifier hs-var">diveDirection</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe DiveDirection
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-36"></span><span>
</span><span id="line-37"></span><span class="annot"><a href="Dive.Dive.html#parseSubMatches"><span class="hs-identifier hs-type">parseSubMatches</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Dive.Dive.html#DiveDirection"><span class="hs-identifier hs-type">DiveDirection</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span>
</span><span id="line-38"></span><span id="parseSubMatches"><span class="annot"><span class="annottext">parseSubMatches :: [String] -&gt; Maybe (DiveDirection, Int)
</span><a href="Dive.Dive.html#parseSubMatches"><span class="hs-identifier hs-var hs-var">parseSubMatches</span></a></span></span><span> </span><span class="hs-special">[</span><span id="local-6989586621679058190"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679058190"><span class="hs-identifier hs-var">dir</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679058189"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679058189"><span class="hs-identifier hs-var">mag</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-39"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679058188"><span class="annot"><span class="annottext">direction :: Maybe DiveDirection
</span><a href="#local-6989586621679058188"><span class="hs-identifier hs-var hs-var">direction</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe DiveDirection
</span><a href="Dive.Dive.html#diveDirection"><span class="hs-identifier hs-var">diveDirection</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679058190"><span class="hs-identifier hs-var">dir</span></a></span><span>
</span><span id="line-40"></span><span>      </span><span id="local-6989586621679058187"><span class="annot"><span class="annottext">magnitude :: Maybe Int
</span><a href="#local-6989586621679058187"><span class="hs-identifier hs-var hs-var">magnitude</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe Int
forall a. Read a =&gt; String -&gt; Maybe a
</span><span class="hs-identifier hs-var">readMaybe</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679058189"><span class="hs-identifier hs-var">mag</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-41"></span><span>      </span><span id="local-6989586621679058186"><span class="annot"><span class="annottext">parsedDirAndMag :: Maybe (DiveDirection, Int)
</span><a href="#local-6989586621679058186"><span class="hs-identifier hs-var hs-var">parsedDirAndMag</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-42"></span><span>        </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Maybe DiveDirection -&gt; Bool
forall a. Maybe a -&gt; Bool
</span><span class="hs-identifier hs-var">isJust</span></span><span> </span><span class="annot"><span class="annottext">Maybe DiveDirection
</span><a href="#local-6989586621679058188"><span class="hs-identifier hs-var">direction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Maybe Int -&gt; Bool
forall a. Maybe a -&gt; Bool
</span><span class="hs-identifier hs-var">isJust</span></span><span> </span><span class="annot"><span class="annottext">Maybe Int
</span><a href="#local-6989586621679058187"><span class="hs-identifier hs-var">magnitude</span></a></span><span>
</span><span id="line-43"></span><span>          </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int) -&gt; Maybe (DiveDirection, Int)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe DiveDirection -&gt; DiveDirection
forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromJust</span></span><span> </span><span class="annot"><span class="annottext">Maybe DiveDirection
</span><a href="#local-6989586621679058188"><span class="hs-identifier hs-var">direction</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Maybe Int -&gt; Int
forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromJust</span></span><span> </span><span class="annot"><span class="annottext">Maybe Int
</span><a href="#local-6989586621679058187"><span class="hs-identifier hs-var">magnitude</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-44"></span><span>          </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Maybe (DiveDirection, Int)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-45"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Maybe (DiveDirection, Int)
</span><a href="#local-6989586621679058186"><span class="hs-identifier hs-var">parsedDirAndMag</span></a></span><span>
</span><span id="line-46"></span><span class="annot"><a href="Dive.Dive.html#parseSubMatches"><span class="hs-identifier hs-var">parseSubMatches</span></a></span><span> </span><span class="annot"><span class="annottext">[String]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (DiveDirection, Int)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-47"></span><span>
</span><span id="line-48"></span><span class="hs-comment">-- Surprised that defining the constant as `STEP_REGEX` does not compile:</span><span>
</span><span id="line-49"></span><span class="hs-comment">--</span><span>
</span><span id="line-50"></span><span class="hs-comment">--    Not in scope: data constructor &#8216;FORWARD&#8217;typecheck</span><span>
</span><span id="line-51"></span><span class="hs-comment">--</span><span>
</span><span id="line-52"></span><span class="hs-comment">-- Variable names must start with a lowercase letter, and anything that is</span><span>
</span><span id="line-53"></span><span class="hs-comment">-- uppercase is interpreted as a Data Constructor. [1]</span><span>
</span><span id="line-54"></span><span class="hs-comment">--</span><span>
</span><span id="line-55"></span><span class="hs-comment">-- [1]: https://stackoverflow.com/a/28381111/7812406</span><span>
</span><span id="line-56"></span><span class="annot"><a href="Dive.Dive.html#stepRegex"><span class="hs-identifier hs-type">stepRegex</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span class="hs-special">]</span><span>
</span><span id="line-57"></span><span id="stepRegex"><span class="annot"><span class="annottext">stepRegex :: String
</span><a href="Dive.Dive.html#stepRegex"><span class="hs-identifier hs-var hs-var">stepRegex</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;([a-z]+) ([0-9]+)&quot;</span></span><span> </span><span class="hs-comment">-- regex-tdfa doesn't have \d for digits</span><span>
</span><span id="line-58"></span><span>
</span><span id="line-59"></span><span class="annot"><a href="Dive.Dive.html#directionAndMagnitude"><span class="hs-identifier hs-type">directionAndMagnitude</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Dive.Dive.html#DiveDirection"><span class="hs-identifier hs-type">DiveDirection</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span id="directionAndMagnitude"><span class="annot"><span class="annottext">directionAndMagnitude :: String -&gt; Maybe (DiveDirection, Int)
</span><a href="Dive.Dive.html#directionAndMagnitude"><span class="hs-identifier hs-var hs-var">directionAndMagnitude</span></a></span></span><span> </span><span id="local-6989586621679058182"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679058182"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-61"></span><span>  </span><span class="hs-comment">-- The format is (beforeMatch, firstMatch, afterMatch, [subMatches])</span><span>
</span><span id="line-62"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679058181"><span class="annot"><span class="annottext">[String]
</span><a href="#local-6989586621679058181"><span class="hs-identifier hs-var">subMatches</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679058182"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; (String, String, String, [String])
forall source source1 target.
(RegexMaker Regex CompOption ExecOption source,
 RegexContext Regex source1 target) =&gt;
source1 -&gt; source -&gt; target
</span><span class="hs-operator hs-var">=~</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="Dive.Dive.html#stepRegex"><span class="hs-identifier hs-var">stepRegex</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-63"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="hs-comment">-- Haskell lists are ordinary single-linked lists. Except operations on the</span><span>
</span><span id="line-64"></span><span>      </span><span class="hs-comment">-- first element (e.g. prepend, get, remove), the rest of the operations</span><span>
</span><span id="line-65"></span><span>      </span><span class="hs-comment">-- (including getting the length and indexing) are linear-time.</span><span>
</span><span id="line-66"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-67"></span><span>      </span><span class="hs-comment">-- [1]: https://wiki.haskell.org/How_to_work_on_lists</span><span>
</span><span id="line-68"></span><span>      </span><span class="annot"><span class="annottext">[String] -&gt; Maybe (DiveDirection, Int)
</span><a href="Dive.Dive.html#parseSubMatches"><span class="hs-identifier hs-var">parseSubMatches</span></a></span><span> </span><span class="annot"><span class="annottext">[String]
</span><a href="#local-6989586621679058181"><span class="hs-identifier hs-var">subMatches</span></a></span><span>
</span><span id="line-69"></span><span>
</span><span id="line-70"></span><span class="annot"><a href="Dive.Dive.html#applySign"><span class="hs-identifier hs-type">applySign</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Dive.Dive.html#DiveDirection"><span class="hs-identifier hs-type">DiveDirection</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-71"></span><span id="applySign"><span class="annot"><span class="annottext">applySign :: (DiveDirection, Int) -&gt; Int
</span><a href="Dive.Dive.html#applySign"><span class="hs-identifier hs-var hs-var">applySign</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DiveDirection
</span><a href="Dive.Dive.html#Up"><span class="hs-identifier hs-var">Up</span></a></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679058179"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058179"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">-</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058179"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-72"></span><span class="annot"><a href="Dive.Dive.html#applySign"><span class="hs-identifier hs-var">applySign</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DiveDirection
</span><a href="Dive.Dive.html#Down"><span class="hs-identifier hs-var">Down</span></a></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679058178"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058178"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058178"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-73"></span><span class="annot"><a href="Dive.Dive.html#applySign"><span class="hs-identifier hs-var">applySign</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DiveDirection
</span><a href="Dive.Dive.html#Forward"><span class="hs-identifier hs-var">Forward</span></a></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679058177"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058177"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058177"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-74"></span><span>
</span><span id="line-75"></span><span class="hs-comment">-- It's common in Haskell to use the apostrophe to signify a relationship to a</span><span>
</span><span id="line-76"></span><span class="hs-comment">-- previously defined item. Similar to how apostrophes are used in math.</span><span>
</span><span id="line-77"></span><span class="hs-comment">--</span><span>
</span><span id="line-78"></span><span class="hs-comment">-- [1]: https://stackoverflow.com/a/5673954/7812406</span><span>
</span><span id="line-79"></span><span class="annot"><a href="Dive.Dive.html#applySign%27"><span class="hs-identifier hs-type">applySign'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Dive.Dive.html#DiveDirection"><span class="hs-identifier hs-type">DiveDirection</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-80"></span><span class="hs-comment">-- Hlint saved me here. My initial implementation was:</span><span>
</span><span id="line-81"></span><span class="hs-comment">--</span><span>
</span><span id="line-82"></span><span class="hs-comment">--    if isJust m then applySign $ fromJust m else 0</span><span>
</span><span id="line-83"></span><span class="hs-comment">--</span><span>
</span><span id="line-84"></span><span class="hs-comment">-- ... and Hlint suggested:</span><span>
</span><span id="line-85"></span><span class="hs-comment">--</span><span>
</span><span id="line-86"></span><span class="hs-comment">--    maybe 0 applySign m</span><span>
</span><span id="line-87"></span><span class="hs-comment">--</span><span>
</span><span id="line-88"></span><span class="hs-comment">-- ... and further suggested dropping the `m` citing Eta reduction. This</span><span>
</span><span id="line-89"></span><span class="hs-comment">-- reduction leads to the cleaner Pointfree style which omits the names of the</span><span>
</span><span id="line-90"></span><span class="hs-comment">-- variables. Pointfree style puts the spotlight on composing functions (high</span><span>
</span><span id="line-91"></span><span class="hs-comment">-- level), rather than shuffling data (low level). [1] [2].</span><span>
</span><span id="line-92"></span><span class="hs-comment">--</span><span>
</span><span id="line-93"></span><span class="hs-comment">-- [1]: https://wiki.haskell.org/Eta_conversion</span><span>
</span><span id="line-94"></span><span class="hs-comment">-- [2]: https://wiki.haskell.org/Pointfree</span><span>
</span><span id="line-95"></span><span class="hs-comment">-- [3]: https://www.schoolofhaskell.com/user/school/starting-with-haskell/introduction-to-haskell/4-higher-order-programming-and-type-inference#wholemeal-programming</span><span>
</span><span id="line-96"></span><span id="applySign%27"><span class="annot"><span class="annottext">applySign' :: Maybe (DiveDirection, Int) -&gt; Int
</span><a href="Dive.Dive.html#applySign%27"><span class="hs-identifier hs-var hs-var">applySign'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
-&gt; ((DiveDirection, Int) -&gt; Int)
-&gt; Maybe (DiveDirection, Int)
-&gt; Int
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int) -&gt; Int
</span><a href="Dive.Dive.html#applySign"><span class="hs-identifier hs-var">applySign</span></a></span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="annot"><a href="Dive.Dive.html#isForward"><span class="hs-identifier hs-type">isForward</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Dive.Dive.html#DiveDirection"><span class="hs-identifier hs-type">DiveDirection</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-99"></span><span id="isForward"><span class="annot"><span class="annottext">isForward :: (DiveDirection, Int) -&gt; Bool
</span><a href="Dive.Dive.html#isForward"><span class="hs-identifier hs-var hs-var">isForward</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DiveDirection
</span><a href="Dive.Dive.html#Forward"><span class="hs-identifier hs-var">Forward</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-100"></span><span class="annot"><a href="Dive.Dive.html#isForward"><span class="hs-identifier hs-var">isForward</span></a></span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-101"></span><span>
</span><span id="line-102"></span><span class="annot"><a href="Dive.Dive.html#cumulativeSums"><span class="hs-identifier hs-type">cumulativeSums</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">]</span><span>
</span><span id="line-103"></span><span id="cumulativeSums"><span class="annot"><span class="annottext">cumulativeSums :: [Int] -&gt; [Int]
</span><a href="Dive.Dive.html#cumulativeSums"><span class="hs-identifier hs-var hs-var">cumulativeSums</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-104"></span><span class="annot"><a href="Dive.Dive.html#cumulativeSums"><span class="hs-identifier hs-var">cumulativeSums</span></a></span><span> </span><span class="hs-special">[</span><span id="local-6989586621679058172"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058172"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058172"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-105"></span><span class="annot"><a href="Dive.Dive.html#cumulativeSums"><span class="hs-identifier hs-var">cumulativeSums</span></a></span><span> </span><span class="hs-special">[</span><span id="local-6989586621679058171"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058171"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679058170"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058170"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058171"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058171"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058170"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-106"></span><span class="annot"><a href="Dive.Dive.html#cumulativeSums"><span class="hs-identifier hs-var">cumulativeSums</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679058168"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058168"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679058167"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058167"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679058166"><span class="annot"><span class="annottext">[Int]
</span><a href="#local-6989586621679058166"><span class="hs-identifier hs-var">zs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058168"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [Int] -&gt; [Int]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Int] -&gt; [Int]
</span><a href="Dive.Dive.html#cumulativeSums"><span class="hs-identifier hs-var">cumulativeSums</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058168"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058167"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [Int] -&gt; [Int]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Int]
</span><a href="#local-6989586621679058166"><span class="hs-identifier hs-var">zs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-107"></span><span>
</span><span id="line-108"></span><span class="annot"><a href="Dive.Dive.html#productOfFinalPosition"><span class="hs-identifier hs-type">productOfFinalPosition</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-109"></span><span id="productOfFinalPosition"><span class="annot"><span class="annottext">productOfFinalPosition :: [String] -&gt; Int
</span><a href="Dive.Dive.html#productOfFinalPosition"><span class="hs-identifier hs-var hs-var">productOfFinalPosition</span></a></span></span><span> </span><span id="local-6989586621679058165"><span class="annot"><span class="annottext">[String]
</span><a href="#local-6989586621679058165"><span class="hs-identifier hs-var">steps</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-110"></span><span>  </span><span class="hs-comment">-- In general, use `where` for locally-defined functions, and `let` for</span><span>
</span><span id="line-111"></span><span>  </span><span class="hs-comment">-- intermediate values. [1]</span><span>
</span><span id="line-112"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-113"></span><span>  </span><span class="hs-comment">-- I don't fully get the nuance in [2], but it might come in handy later as</span><span>
</span><span id="line-114"></span><span>  </span><span class="hs-comment">-- I get more experience with Haskell. A broad stroke would be `let` places</span><span>
</span><span id="line-115"></span><span>  </span><span class="hs-comment">-- fewer restrictions, and `where` is more readable, but `where` may obscure</span><span>
</span><span id="line-116"></span><span>  </span><span class="hs-comment">-- inefficient code that redefines local functions.</span><span>
</span><span id="line-117"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-118"></span><span>  </span><span class="hs-comment">-- [1]: http://www.cse.unsw.edu.au/~cs3161/14s2/StyleGuide.html#sec-5-1-1</span><span>
</span><span id="line-119"></span><span>  </span><span class="hs-comment">-- [2]: https://wiki.haskell.org/Let_vs._Where</span><span>
</span><span id="line-120"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679058164"><span class="annot"><span class="annottext">parsedSteps :: [(DiveDirection, Int)]
</span><a href="#local-6989586621679058164"><span class="hs-identifier hs-var hs-var">parsedSteps</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(String -&gt; Maybe (DiveDirection, Int))
-&gt; [String] -&gt; [(DiveDirection, Int)]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe (DiveDirection, Int)
</span><a href="Dive.Dive.html#directionAndMagnitude"><span class="hs-identifier hs-var">directionAndMagnitude</span></a></span><span> </span><span class="annot"><span class="annottext">[String]
</span><a href="#local-6989586621679058165"><span class="hs-identifier hs-var">steps</span></a></span><span>
</span><span id="line-121"></span><span>
</span><span id="line-122"></span><span>      </span><span class="hs-comment">-- `fst` and `snd` are utility functions for the first and second members</span><span>
</span><span id="line-123"></span><span>      </span><span class="hs-comment">-- of a pair, respectively. [1]</span><span>
</span><span id="line-124"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-125"></span><span>      </span><span class="hs-comment">-- [1]: https://en.wikibooks.org/wiki/Haskell/Lists_and_tuples</span><span>
</span><span id="line-126"></span><span>
</span><span id="line-127"></span><span>      </span><span class="hs-comment">-- How do I compute `horizontalPos` and `verticalPos` while iterating</span><span>
</span><span id="line-128"></span><span>      </span><span class="hs-comment">-- through `parsedSteps` once? From an imperative programming background,</span><span>
</span><span id="line-129"></span><span>      </span><span class="hs-comment">-- this looks pretty inefficient! Update: [1] suggests the `foldl`</span><span>
</span><span id="line-130"></span><span>      </span><span class="hs-comment">-- package.</span><span>
</span><span id="line-131"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-132"></span><span>      </span><span class="hs-comment">-- [1]: https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Foldable.html#g:18</span><span>
</span><span id="line-133"></span><span>      </span><span id="local-6989586621679058163"><span class="annot"><span class="annottext">finalHorizontalPos :: Int
</span><a href="#local-6989586621679058163"><span class="hs-identifier hs-var hs-var">finalHorizontalPos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Int] -&gt; Int
forall (t :: * -&gt; *) a. (Foldable t, Num a) =&gt; t a -&gt; a
</span><span class="hs-identifier hs-var">sum</span></span><span> </span><span class="annot"><span class="annottext">([Int] -&gt; Int) -&gt; [Int] -&gt; Int
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">((DiveDirection, Int) -&gt; Int) -&gt; [(DiveDirection, Int)] -&gt; [Int]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int) -&gt; Int
</span><a href="Dive.Dive.html#applySign"><span class="hs-identifier hs-var">applySign</span></a></span><span> </span><span class="annot"><span class="annottext">([(DiveDirection, Int)] -&gt; [Int])
-&gt; [(DiveDirection, Int)] -&gt; [Int]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">((DiveDirection, Int) -&gt; Bool)
-&gt; [(DiveDirection, Int)] -&gt; [(DiveDirection, Int)]
forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">filter</span></span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int) -&gt; Bool
</span><a href="Dive.Dive.html#isForward"><span class="hs-identifier hs-var">isForward</span></a></span><span> </span><span class="annot"><span class="annottext">[(DiveDirection, Int)]
</span><a href="#local-6989586621679058164"><span class="hs-identifier hs-var">parsedSteps</span></a></span><span>
</span><span id="line-134"></span><span>
</span><span id="line-135"></span><span>      </span><span class="hs-comment">-- The function composition operator is handy when inverting the filter</span><span>
</span><span id="line-136"></span><span>      </span><span class="hs-comment">-- predicate.</span><span>
</span><span id="line-137"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-138"></span><span>      </span><span class="hs-comment">-- [1]: https://techoverflow.net/2014/01/03/haskell-invert-filter-predicate/</span><span>
</span><span id="line-139"></span><span>      </span><span id="local-6989586621679058161"><span class="annot"><span class="annottext">finalVerticalPos :: Int
</span><a href="#local-6989586621679058161"><span class="hs-identifier hs-var hs-var">finalVerticalPos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Int] -&gt; Int
forall (t :: * -&gt; *) a. (Foldable t, Num a) =&gt; t a -&gt; a
</span><span class="hs-identifier hs-var">sum</span></span><span> </span><span class="annot"><span class="annottext">([Int] -&gt; Int) -&gt; [Int] -&gt; Int
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">((DiveDirection, Int) -&gt; Int) -&gt; [(DiveDirection, Int)] -&gt; [Int]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int) -&gt; Int
</span><a href="Dive.Dive.html#applySign"><span class="hs-identifier hs-var">applySign</span></a></span><span> </span><span class="annot"><span class="annottext">([(DiveDirection, Int)] -&gt; [Int])
-&gt; [(DiveDirection, Int)] -&gt; [Int]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">((DiveDirection, Int) -&gt; Bool)
-&gt; [(DiveDirection, Int)] -&gt; [(DiveDirection, Int)]
forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">filter</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool)
-&gt; ((DiveDirection, Int) -&gt; Bool) -&gt; (DiveDirection, Int) -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int) -&gt; Bool
</span><a href="Dive.Dive.html#isForward"><span class="hs-identifier hs-var">isForward</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[(DiveDirection, Int)]
</span><a href="#local-6989586621679058164"><span class="hs-identifier hs-var">parsedSteps</span></a></span><span>
</span><span id="line-140"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058163"><span class="hs-identifier hs-var">finalHorizontalPos</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">*</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058161"><span class="hs-identifier hs-var">finalVerticalPos</span></a></span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span class="annot"><a href="Dive.Dive.html#productOfFinalPositionWithNewIntepretation"><span class="hs-identifier hs-type">productOfFinalPositionWithNewIntepretation</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-143"></span><span id="productOfFinalPositionWithNewIntepretation"><span class="annot"><span class="annottext">productOfFinalPositionWithNewIntepretation :: [String] -&gt; Int
</span><a href="Dive.Dive.html#productOfFinalPositionWithNewIntepretation"><span class="hs-identifier hs-var hs-var">productOfFinalPositionWithNewIntepretation</span></a></span></span><span> </span><span id="local-6989586621679058157"><span class="annot"><span class="annottext">[String]
</span><a href="#local-6989586621679058157"><span class="hs-identifier hs-var">steps</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-144"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679058156"><span class="annot"><span class="annottext">parsedSteps :: [(DiveDirection, Int)]
</span><a href="#local-6989586621679058156"><span class="hs-identifier hs-var hs-var">parsedSteps</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(String -&gt; Maybe (DiveDirection, Int))
-&gt; [String] -&gt; [(DiveDirection, Int)]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe (DiveDirection, Int)
</span><a href="Dive.Dive.html#directionAndMagnitude"><span class="hs-identifier hs-var">directionAndMagnitude</span></a></span><span> </span><span class="annot"><span class="annottext">[String]
</span><a href="#local-6989586621679058157"><span class="hs-identifier hs-var">steps</span></a></span><span>
</span><span id="line-145"></span><span>      </span><span id="local-6989586621679058155"><span class="annot"><span class="annottext">finalHorizontalPos :: Int
</span><a href="#local-6989586621679058155"><span class="hs-identifier hs-var hs-var">finalHorizontalPos</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Int] -&gt; Int
forall (t :: * -&gt; *) a. (Foldable t, Num a) =&gt; t a -&gt; a
</span><span class="hs-identifier hs-var">sum</span></span><span> </span><span class="annot"><span class="annottext">([Int] -&gt; Int) -&gt; [Int] -&gt; Int
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">((DiveDirection, Int) -&gt; Int) -&gt; [(DiveDirection, Int)] -&gt; [Int]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int) -&gt; Int
</span><a href="Dive.Dive.html#applySign"><span class="hs-identifier hs-var">applySign</span></a></span><span> </span><span class="annot"><span class="annottext">([(DiveDirection, Int)] -&gt; [Int])
-&gt; [(DiveDirection, Int)] -&gt; [Int]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">((DiveDirection, Int) -&gt; Bool)
-&gt; [(DiveDirection, Int)] -&gt; [(DiveDirection, Int)]
forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">filter</span></span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int) -&gt; Bool
</span><a href="Dive.Dive.html#isForward"><span class="hs-identifier hs-var">isForward</span></a></span><span> </span><span class="annot"><span class="annottext">[(DiveDirection, Int)]
</span><a href="#local-6989586621679058156"><span class="hs-identifier hs-var">parsedSteps</span></a></span><span>
</span><span id="line-146"></span><span>      </span><span class="hs-comment">-- Hlint suggestion on using map once was illuminating. I had code like:</span><span>
</span><span id="line-147"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-148"></span><span>      </span><span class="hs-comment">--    l = ([1..10] :: [Int])</span><span>
</span><span id="line-149"></span><span>      </span><span class="hs-comment">--    map even $ map negate l</span><span>
</span><span id="line-150"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-151"></span><span>      </span><span class="hs-comment">-- ... for which Hlint suggested:</span><span>
</span><span id="line-152"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-153"></span><span>      </span><span class="hs-comment">--    map (even . negate) l</span><span>
</span><span id="line-154"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-155"></span><span>      </span><span class="hs-comment">-- ... and that makes sense. Composition strikes again!</span><span>
</span><span id="line-156"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-157"></span><span>      </span><span class="hs-comment">-- That said, the (.) can be unwieldy because we normally read from left</span><span>
</span><span id="line-158"></span><span>      </span><span class="hs-comment">-- to right, but (.) composition is read from right to left. For extra</span><span>
</span><span id="line-159"></span><span>      </span><span class="hs-comment">-- readability, we can use the (&gt;&gt;&gt;) operator from `Control.Arrow`, e.g.</span><span>
</span><span id="line-160"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-161"></span><span>      </span><span class="hs-comment">--    map (negate &gt;&gt;&gt; even) l</span><span>
</span><span id="line-162"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-163"></span><span>      </span><span class="hs-comment">-- ... as it flips the (.) operator. [1]</span><span>
</span><span id="line-164"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-165"></span><span>      </span><span class="hs-comment">-- [1]: https://byorgey.wordpress.com/2019/04/24/competitive-programming-in-haskell-basic-setup/</span><span>
</span><span id="line-166"></span><span>      </span><span id="local-6989586621679058154"><span class="annot"><span class="annottext">aimDeltas :: [Int]
</span><a href="#local-6989586621679058154"><span class="hs-identifier hs-var hs-var">aimDeltas</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-167"></span><span>        </span><span class="annot"><span class="annottext">((DiveDirection, Int) -&gt; Int) -&gt; [(DiveDirection, Int)] -&gt; [Int]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span>
</span><span id="line-168"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (DiveDirection, Int) -&gt; Int
</span><a href="Dive.Dive.html#applySign%27"><span class="hs-identifier hs-var">applySign'</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe (DiveDirection, Int) -&gt; Int)
-&gt; ((DiveDirection, Int) -&gt; Maybe (DiveDirection, Int))
-&gt; (DiveDirection, Int)
-&gt; Int
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679058153"><span class="annot"><span class="annottext">(DiveDirection, Int)
</span><a href="#local-6989586621679058153"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool)
-&gt; ((DiveDirection, Int) -&gt; Bool) -&gt; (DiveDirection, Int) -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int) -&gt; Bool
</span><a href="Dive.Dive.html#isForward"><span class="hs-identifier hs-var">isForward</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int)
</span><a href="#local-6989586621679058153"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int) -&gt; Maybe (DiveDirection, Int)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int)
</span><a href="#local-6989586621679058153"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Maybe (DiveDirection, Int)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-169"></span><span>          </span><span class="annot"><span class="annottext">[(DiveDirection, Int)]
</span><a href="#local-6989586621679058156"><span class="hs-identifier hs-var">parsedSteps</span></a></span><span>
</span><span id="line-170"></span><span>
</span><span id="line-171"></span><span>      </span><span class="hs-comment">-- How do I do cumulative sums, i.e. [1, 2, 3, 4] -&gt; [1, 3, 6, 10]? The end</span><span>
</span><span id="line-172"></span><span>      </span><span class="hs-comment">-- result is a list, so maybe something to do with `map`, but how do I</span><span>
</span><span id="line-173"></span><span>      </span><span class="hs-comment">-- reference what came before? Maybe a standalone function with pattern</span><span>
</span><span id="line-174"></span><span>      </span><span class="hs-comment">-- matching?</span><span>
</span><span id="line-175"></span><span>      </span><span id="local-6989586621679058152"><span class="annot"><span class="annottext">cumulativeAims :: [Int]
</span><a href="#local-6989586621679058152"><span class="hs-identifier hs-var hs-var">cumulativeAims</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Int] -&gt; [Int]
</span><a href="Dive.Dive.html#cumulativeSums"><span class="hs-identifier hs-var">cumulativeSums</span></a></span><span> </span><span class="annot"><span class="annottext">[Int]
</span><a href="#local-6989586621679058154"><span class="hs-identifier hs-var">aimDeltas</span></a></span><span>
</span><span id="line-176"></span><span>
</span><span id="line-177"></span><span>      </span><span id="local-6989586621679058151"><span class="annot"><span class="annottext">forwardDeltas :: [Int]
</span><a href="#local-6989586621679058151"><span class="hs-identifier hs-var hs-var">forwardDeltas</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-178"></span><span>        </span><span class="annot"><span class="annottext">((DiveDirection, Int) -&gt; Int) -&gt; [(DiveDirection, Int)] -&gt; [Int]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span>
</span><span id="line-179"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (DiveDirection, Int) -&gt; Int
</span><a href="Dive.Dive.html#applySign%27"><span class="hs-identifier hs-var">applySign'</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe (DiveDirection, Int) -&gt; Int)
-&gt; ((DiveDirection, Int) -&gt; Maybe (DiveDirection, Int))
-&gt; (DiveDirection, Int)
-&gt; Int
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679058150"><span class="annot"><span class="annottext">(DiveDirection, Int)
</span><a href="#local-6989586621679058150"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int) -&gt; Bool
</span><a href="Dive.Dive.html#isForward"><span class="hs-identifier hs-var">isForward</span></a></span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int)
</span><a href="#local-6989586621679058150"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int) -&gt; Maybe (DiveDirection, Int)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(DiveDirection, Int)
</span><a href="#local-6989586621679058150"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Maybe (DiveDirection, Int)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-180"></span><span>          </span><span class="annot"><span class="annottext">[(DiveDirection, Int)]
</span><a href="#local-6989586621679058156"><span class="hs-identifier hs-var">parsedSteps</span></a></span><span>
</span><span id="line-181"></span><span>
</span><span id="line-182"></span><span>      </span><span class="hs-comment">-- In other languages, moving from a list to a single value is referred to</span><span>
</span><span id="line-183"></span><span>      </span><span class="hs-comment">-- as a reduction. Haskell uses the term &quot;folding&quot;. On lists, one can</span><span>
</span><span id="line-184"></span><span>      </span><span class="hs-comment">-- either recursively combine the 1st element with the result of combining</span><span>
</span><span id="line-185"></span><span>      </span><span class="hs-comment">-- the rest (right fold), or recursively combine the results of combining</span><span>
</span><span id="line-186"></span><span>      </span><span class="hs-comment">-- all but the last element with the last element (left fold). Some</span><span>
</span><span id="line-187"></span><span>      </span><span class="hs-comment">-- initial value is provided that is combined with the first item in the</span><span>
</span><span id="line-188"></span><span>      </span><span class="hs-comment">-- list. There are some nuances:</span><span>
</span><span id="line-189"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-190"></span><span>      </span><span class="hs-comment">--   `foldr` lazily evaluates the recursive case of folding over the rest</span><span>
</span><span id="line-191"></span><span>      </span><span class="hs-comment">--   of the list. This allows it to handle computations on infinite lists</span><span>
</span><span id="line-192"></span><span>      </span><span class="hs-comment">--   that either produce some result without referencing the recursive</span><span>
</span><span id="line-193"></span><span>      </span><span class="hs-comment">--   case, or short-circuit (e.g. `||` short-circuits on the first</span><span>
</span><span id="line-194"></span><span>      </span><span class="hs-comment">--   `True`).</span><span>
</span><span id="line-195"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-196"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-197"></span><span>      </span><span class="hs-comment">--   `foldl` immediately calls itself with new params until it reaches the</span><span>
</span><span id="line-198"></span><span>      </span><span class="hs-comment">--   end of the list (and thus can't handle infinite loops). However, its</span><span>
</span><span id="line-199"></span><span>      </span><span class="hs-comment">--   tail recursiveness (the final result of the recursive call is the</span><span>
</span><span id="line-200"></span><span>      </span><span class="hs-comment">--   final result of the function itself) can be efficiently compiled as a</span><span>
</span><span id="line-201"></span><span>      </span><span class="hs-comment">--   as a loop.</span><span>
</span><span id="line-202"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-203"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-204"></span><span>      </span><span class="hs-comment">--   `foldl` does not evaluate the initial parameter before the recursive</span><span>
</span><span id="line-205"></span><span>      </span><span class="hs-comment">--   call is made. At the end of the list, we may end up with a gigantic</span><span>
</span><span id="line-206"></span><span>      </span><span class="hs-comment">--   expression that causes stack overflow. Haskell provides the `foldl'`</span><span>
</span><span id="line-207"></span><span>      </span><span class="hs-comment">--   function that forces evaluation of the initial parameter before</span><span>
</span><span id="line-208"></span><span>      </span><span class="hs-comment">--   making the recursive call.</span><span>
</span><span id="line-209"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-210"></span><span>      </span><span class="hs-comment">-- From [1] [2]. [3] and [4] goes into way more detail, and are worth a</span><span>
</span><span id="line-211"></span><span>      </span><span class="hs-comment">-- closer read.</span><span>
</span><span id="line-212"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-213"></span><span>      </span><span class="hs-comment">-- That said, I still don't know how to summarize `(zip forwardDeltas</span><span>
</span><span id="line-214"></span><span>      </span><span class="hs-comment">-- aimDeltas)`. `foldl` and `foldr` accept operators, but there's no</span><span>
</span><span id="line-215"></span><span>      </span><span class="hs-comment">-- operator for &quot;increase depth value by aim multiplied by X&quot;. Seems like</span><span>
</span><span id="line-216"></span><span>      </span><span class="hs-comment">-- `foldMap` is the place to be, but WHAT IS A MONOID?</span><span>
</span><span id="line-217"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-218"></span><span>      </span><span class="hs-comment">-- Update: Misread the docs. `fold` and `foldMap` need monoids, but</span><span>
</span><span id="line-219"></span><span>      </span><span class="hs-comment">-- `foldl` and `foldr` have examples with lambdas. Nice!</span><span>
</span><span id="line-220"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-221"></span><span>      </span><span class="hs-comment">-- [1]: https://wiki.haskell.org/Fold</span><span>
</span><span id="line-222"></span><span>      </span><span class="hs-comment">-- [2]: https://wiki.haskell.org/Tail_recursion</span><span>
</span><span id="line-223"></span><span>      </span><span class="hs-comment">-- [3]: https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Foldable.html#overview</span><span>
</span><span id="line-224"></span><span>      </span><span class="hs-comment">-- [4]: https://www.schoolofhaskell.com/user/school/starting-with-haskell/introduction-to-haskell/6-laziness</span><span>
</span><span id="line-225"></span><span>
</span><span id="line-226"></span><span>      </span><span class="hs-comment">-- My version had:</span><span>
</span><span id="line-227"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-228"></span><span>      </span><span class="hs-comment">--    (fst p * snd p)</span><span>
</span><span id="line-229"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-230"></span><span>      </span><span class="hs-comment">-- ... and Hlint proposed the use of uncurry, which converts a curried</span><span>
</span><span id="line-231"></span><span>      </span><span class="hs-comment">-- function to a function on pairs. That's pretty neat.</span><span>
</span><span id="line-232"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-233"></span><span>      </span><span class="hs-comment">-- [1]: https://hackage.haskell.org/package/base-4.16.0.0/docs/Prelude.html#v:uncurry</span><span>
</span><span id="line-234"></span><span>
</span><span id="line-235"></span><span>      </span><span class="hs-comment">-- Lambda abstractions can also have multiple arguments. For example:</span><span>
</span><span id="line-236"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-237"></span><span>      </span><span class="hs-comment">--    \x y z -&gt; [x, 2 * y, 3 * z]</span><span>
</span><span id="line-238"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-239"></span><span>      </span><span class="hs-comment">-- ... is an anonymous function that takes 3 arguments.</span><span>
</span><span id="line-240"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-241"></span><span>      </span><span class="hs-comment">-- [1]: https://www.schoolofhaskell.com/user/school/starting-with-haskell/introduction-to-haskell/4-higher-order-programming-and-type-inference#anonymous-functions</span><span>
</span><span id="line-242"></span><span>      </span><span id="local-6989586621679058149"><span class="annot"><span class="annottext">finalDepth :: Int
</span><a href="#local-6989586621679058149"><span class="hs-identifier hs-var hs-var">finalDepth</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-243"></span><span>        </span><span class="annot"><span class="annottext">((Int, Int) -&gt; Int -&gt; Int) -&gt; Int -&gt; [(Int, Int)] -&gt; Int
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span>
</span><span id="line-244"></span><span>          </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679058147"><span class="annot"><span class="annottext">(Int, Int)
</span><a href="#local-6989586621679058147"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679058146"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058146"><span class="hs-identifier hs-var">depthSoFar</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058146"><span class="hs-identifier hs-var">depthSoFar</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">(Int -&gt; Int -&gt; Int) -&gt; (Int, Int) -&gt; Int
forall a b c. (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
</span><span class="hs-identifier hs-var">uncurry</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">(*)</span></span><span> </span><span class="annot"><span class="annottext">(Int, Int)
</span><a href="#local-6989586621679058147"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-245"></span><span>          </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-246"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Int] -&gt; [Int] -&gt; [(Int, Int)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Int]
</span><a href="#local-6989586621679058151"><span class="hs-identifier hs-var">forwardDeltas</span></a></span><span> </span><span class="annot"><span class="annottext">[Int]
</span><a href="#local-6989586621679058152"><span class="hs-identifier hs-var">cumulativeAims</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-247"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058155"><span class="hs-identifier hs-var">finalHorizontalPos</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">*</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679058149"><span class="hs-identifier hs-var">finalDepth</span></a></span><span>
</span><span id="line-248"></span></pre></body></html>